#include <stdint.h>

#include "hal_data.h"
#include "hal_device.h"
#include "neopixel.h"
#include "pixelkey.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

#define NPDATA_GPT_BUFFER_LENGTH    (PIXELKEY_NEOPIXEL_COUNT * NEOPIXEL_COLOR_BITS)

#define NPDATA_GPT_B1               (30)
#define NPDATA_GPT_B0               (15)

uint32_t g_npdata_gpt_buffer[NPDATA_GPT_BUFFER_LENGTH] = {0};

static void set_color(uint8_t index, color_t * const color)
{
    color_rgb_t rgb;
    color_convert2(color->color_space, COLOR_SPACE_RGB, (color_kind_t *)&color->hsv, (color_kind_t *)&rgb);

    const neopixel_data_t data = {
        .gbr = {
            .green = rgb.green,
            .red = rgb.red,
            .blue = rgb.blue
        }
    };

    const uint8_t offset_idx = index * NEOPIXEL_COLOR_BITS;
    for (uint8_t i = 0; i < NEOPIXEL_COLOR_BITS; i++)
    {
        const uint8_t byte = i >> 3;
        const uint8_t bit = i & 0x7;

        g_npdata_gpt_buffer[offset_idx + i] = ((data.array[byte] >> bit) & 0x01) ? NPDATA_GPT_B1 : NPDATA_GPT_B0;
    }
} 

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* Initial hardware testing. */
    transfer_info_t * p_tfr = g_npdata_transfer_cfg.p_info; 
    p_tfr->p_src = g_npdata_gpt_buffer;
    //p_tfr->p_dest = &R_GPT5->GTCCR[4];
    p_tfr->length = NPDATA_GPT_BUFFER_LENGTH;

    set_color(0, &color_red);
    set_color(1, &color_red);
    set_color(2, &color_red);
    set_color(3, &color_red);

    g_npdata_timer.p_api->open(&g_npdata_timer_ctrl, &g_npdata_timer_cfg);
    R_GPT5->GTCCR[1] = 0;
    R_GPT5->GTCCR[3] = 0;

    g_npdata_transfer.p_api->open(&g_npdata_transfer_ctrl, &g_npdata_transfer_cfg);
    g_npdata_transfer.p_api->enable(&g_npdata_transfer_ctrl);

    g_npdata_timer.p_api->start(&g_npdata_timer_ctrl);

    transfer_properties_t tinfo;
    do
    {
        g_npdata_transfer.p_api->infoGet(&g_npdata_transfer_ctrl, &tinfo);
    } while (tinfo.transfer_length_remaining > 0);

    g_npdata_timer.p_api->stop(&g_npdata_timer_ctrl);
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
